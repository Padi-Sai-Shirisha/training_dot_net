Concurrency - presentation - Arkapravo Ganguly

Class: PLSQL
====================================================================================================================================================================================

CREATE FUNCTION udfNetSale(
    @quantity INT,
    @list_price DEC(10,2),
    @discount DEC(4,2)
)
RETURNS DEC(10,2)
AS 
BEGIN
    RETURN @quantity * @list_price * (1 - @discount);
END;

SELECT dbo.udfNetSale(10,100,0.1) as net_sale;  --900

SELECT testdb.dbo.udfNetSale(10,list_price,0.1) as net_sale from bikestores.production.products;

====================================================================================================================================================================================

CREATE FUNCTION fn(
    @number INT
)
RETURNS INT
AS 
BEGIN
	DECLARE @x INT = @number;
	DECLARE @sm INT = 0;
	WHILE @x > 0
	BEGIN
	       set @sm = @x + @sm;
	       set @x = @x - 1;
	END
    RETURN @sm;
END;

Select dbo.fn(5);

====================================================================================================================================================================================

Alter FUNCTION fn(
    @number INT
)
RETURNS INT
AS 
BEGIN
	DECLARE @x INT = @number;
	DECLARE @sm INT = 1;
	WHILE @x > 0
	BEGIN
	       set @sm = @x * @sm;
	       set @x = @x - 1;
	END
    RETURN @sm;
END;

Select dbo.fn(5);

====================================================================================================================================================================================
create or Alter FUNCTION fn2(
    @number INT
)
RETURNS INT
AS 
BEGIN
	DECLARE @x INT = @number;
	DECLARE @sm INT = 1;
	WHILE @x > 0
	BEGIN
	       set @sm = @x * @sm;
	       set @x = @x - 1;
	END
    RETURN @sm;
END;

Select dbo.fn2(5);

====================================================================================================================================================================================

DROP FUNCTION dbo.fn2;

====================================================================================================================================================================================
Question: Create function for chkPRime(list_price) which returns even, odd, oddPrime

Solution:

CREATE OR ALTER FUNCTION chkPrime (@number INT)
RETURNS VARCHAR(MAX)
AS
BEGIN
    DECLARE @x INT = @number;
    DECLARE @counter INT = 2;
    DECLARE @is_prime INT = 1;
	DECLARE @is_even INT = 0;
    DECLARE @type VARCHAR(MAX);

    IF @x % 2 = 0
	BEGIN
        SET @type = 'even';
		SET @is_even = 1;
	END
    ELSE
    BEGIN
        WHILE (@counter <= @number / 2)
        BEGIN
            IF ((@number % @counter) = 0)
            BEGIN
                SET @type = 'odd';
                SET @is_prime = 0;
                BREAK;
            END
            SET @counter = @counter + 1;
        END
    END

    IF @is_prime = 1 AND @is_even = 0
        SET @type = 'oddPrime';

    RETURN @type;
END

SELECT dbo.chkPRime(9) as type_check;
SELECT dbo.chkPRime(list_price) as type_check from bikestores.production.products;

====================================================================================================================================================================================

BEGIN
DECLARE @product_table TABLE (
    product_name VARCHAR(MAX) NOT NULL,
    brand_id INT NOT NULL,
    list_price DEC(11,2) NOT NULL
);
INSERT INTO @product_table
     SELECT product_name, brand_id, list_price
         FROM BikeStores.production.products WHERE category_id = 1;

SELECT  * FROM @product_table;
END


====================================================================================================================================================================================

BEGIN
DECLARE @product_table TABLE (
    product_name VARCHAR(MAX) NOT NULL,
    brand_id INT NOT NULL,
    list_price DEC(11,2) NOT NULL
);
INSERT INTO @product_table
     SELECT product_name, brand_id, list_price
         FROM BikeStores.production.products WHERE category_id = 1;

SELECT  p.product_name, p.brand_id, p.list_price FROM @product_table p join BikeStores.production.products
on p.list_price=BikeStores.production.products.list_price;
END

====================================================================================================================================================================================

CREATE OR ALTER FUNCTION udfSplit(
    @string VARCHAR(MAX))
RETURNS @parts TABLE (    
idx INT IDENTITY PRIMARY KEY,
val VARCHAR(MAX)   
)  AS
BEGIN
   INSERT INTO @parts  VALUES (@string);
   RETURN
END

select * from dbo.udfSplit('str1');

====================================================================================================================================================================================

CREATE OR ALTER FUNCTION udfSplit(
    @string VARCHAR(MAX), 
    @delimiter VARCHAR(50) = ' ')
RETURNS @parts TABLE
(    
idx INT IDENTITY PRIMARY KEY,
val VARCHAR(MAX)   
)	AS
BEGIN
DECLARE @index INT = -1;
WHILE (LEN(@string) > 0) 
BEGIN 
    SET @index = CHARINDEX(@delimiter , @string)  ;
    IF (@index = 0) AND (LEN(@string) > 0)  
    BEGIN  
        INSERT INTO @parts  VALUES (@string);
        BREAK  
    END 
    IF (@index > 1)  
    BEGIN  
        INSERT INTO @parts VALUES (LEFT(@string, @index - 1));
		SET @string = RIGHT(@string, (LEN(@string) - @index));  
    END 
    ELSE
		SET @string = RIGHT(@string, (LEN(@string) - @index)); 
    END
RETURN
END

select * from dbo.udfSplit('The function ufnSplit() returns a table variable', ' ');

select * from dbo.udfSplit('The function ufnSplit() returns a table variable', default);

select * from dbo.udfSplit('The,function,ufnSplit(),returns,a,table,variable', ',');

====================================================================================================================================================================================
Question: Define a table variable function which has same number of rows as customers with columns as:
Customer_id : same as table
Zip_code : same as table
Eligible4Gift: calculated as (yes/no) according to whether the zip_code is prime or not. (use the scalar function chkPrime() and case..when..then or if..else to insert the value into the table variable).
The function returns the table to be displayed later.

Solution:

use testdb;

drop table if exists customers;
select* into customers from BikeStores.sales.customers;
select* from customers;


CREATE FUNCTION GiftEligibility()
RETURNS @gift_table TABLE (
    customer_id INT,
    zip_code INT,
    Eligible4gift VARCHAR(MAX)
)
AS
BEGIN
    INSERT INTO @gift_table (customer_id, zip_code, Eligible4gift)
    SELECT customer_id, zip_code,
           CASE WHEN dbo.chkPrime(zip_code) = 'oddPrime' THEN 'yes' ELSE 'no' END AS Eligibility
    FROM customers;

    RETURN;
END;

SELECT * FROM dbo.GiftEligibility();

====================================================================================================================================================================================

CREATE FUNCTION udfProductInYear (
    @model_year INT
)
RETURNS TABLE
AS
RETURN
    SELECT 
        product_name,
        model_year,
        list_price
    FROM
         BikeStores.production.products
    WHERE
        model_year = @model_year;

select * from dbo.udfProductInYear(2016);

====================================================================================================================================================================================

drop table orders;
drop table customers;

CREATE TABLE CUSTOMERS(
   ID   INT              NOT NULL,
   NAME VARCHAR (20)     NOT NULL,
   AGE  INT              NOT NULL,
   ADDRESS  CHAR (25) ,
   SALARY   DECIMAL (18, 2),       
   PRIMARY KEY (ID)
);
INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (2, 'Khilan', 25, 'Delhi', 1500.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (3, 'kaushik', 23, 'Kota', 2000.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (5, 'Hardik', 27, 'Bhopal', 8500.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (6, 'Komal', 22, 'MP', 4500.00 );

INSERT INTO CUSTOMERS VALUES (7, 'Muffy', 24, 'Indore', 10000.00 );

select * from customers;

CREATE or ALTER PROCEDURE SelectCustomerstabledata 
AS 
SELECT * FROM Customers

Exec SelectCustomerstabledata;

====================================================================================================================================================================================

DROP PROC SelectCustomerstabledata;

====================================================================================================================================================================================

CREATE or alter PROCEDURE SelectCustomerstabledata 
(@age AS Int)
AS 
Begin
SELECT * FROM Customers where age>@age
End
--Executing:
Exec SelectCustomerstabledata 25

====================================================================================================================================================================================
Question:

CREATE or alter PROCEDURE printnum 
(@n AS Int)
AS 
Begin

	DECLARE @x iNt = @n;
	WHILE @x > 0
	BEGIN
		SELECT @x;
		SET @x = @x-1;
	end
End
--Executing:
Exec printnum 25

====================================================================================================================================================================================

--Example to pass the table name as procedure parameter: 
CREATE or alter PROCEDURE SelectCustomerstabledata 
(@tblName as varchar(26))
AS 
Begin
    declare @sqlStmt nvarchar(MAX) --varchar(MAX)
    set @sqlStmt = 'SELECT * FROM ' + @tblName 
    exec sp_executesql @sqlStmt
    --exec @sqlStmt
End
--Executing:
Exec SelectCustomerstabledata 'Customers'

====================================================================================================================================================================================

Begin
declare @var nvarchar(max);
set @var = 'select * from customers';
exec sp_executesql @var;
end;

====================================================================================================================================================================================

CREATE or alter PROCEDURE SelectCustomerstabledata 
(@agemin AS Int, @agemax AS Int)
AS 
Begin
SELECT * FROM Customers where age between @agemin and @agemax
End
--Executing the procedure
Exec SelectCustomerstabledata 25, 27 

EXECUTE SelectCustomerstabledata 
    @agemax = 27, 
    @agemin = 25;

====================================================================================================================================================================================

CREATE or alter PROCEDURE SelectCustomerstabledata 
(@agemin Int, @agemax Int, @rownum int output)
AS 
Begin
    SELECT * FROM Customers where age between @agemin and @agemax;
     select @rownum= @@ROWCOUNT;
End

--Executing the procedure
Begin
DECLARE @count INT;

EXECUTE SelectCustomerstabledata 
    @agemax = 25, @agemin = 22,
    @rownum = @count OUTPUT;
--EXECUTE SelectCustomerstabledata 
--    22, 25, @count OUTPUT;

--SELECT @count AS 'Number of Customers found';
print 'Number of Customers found : ' + cast(@count as varchar);
End

====================================================================================================================================================================================

CREATE or alter PROCEDURE SelectCustomerstabledata 
(@agemin AS Int = 18, @agemax AS Int)
AS 
Begin
SELECT * FROM Customers where age between @agemin and @agemax
End

EXECUTE SelectCustomerstabledata 
    @agemax = 25;

Exec SelectCustomerstabledata 25, 27 

Exec SelectCustomerstabledata default, 27 

EXECUTE SelectCustomerstabledata 
    @agemax = 27, 
    @agemin = 25;

====================================================================================================================================================================================
Topic: cursor *************************

drop table if exists products;

CREATE TABLE products (
	product_id INT IDENTITY (1, 1) PRIMARY KEY,
	product_name VARCHAR (255) NOT NULL,
	brand_id INT NOT NULL,
	category_id INT NOT NULL,
	model_year SMALLINT NOT NULL,
	list_price DECIMAL (10, 2) NOT NULL);

INSERT INTO products
VALUES 
 	('Test product1', 1, 1, 2018, 599),
 	('Test product2', 2, 2, 2016, 699),
 	('Test product3', 3, 3, 2018, 799),
 	('Test product4', 4, 4, 2015, 899);

select * from products;


Begin
DECLARE 
    @product_name VARCHAR(MAX), 
    @list_price   DECIMAL;

DECLARE cursor_product CURSOR
FOR SELECT 
        product_name,   list_price
    FROM   products;

OPEN cursor_product;

FETCH NEXT FROM cursor_product INTO 
    @product_name,   @list_price;

WHILE @@FETCH_STATUS = 0
    BEGIN
        PRINT @product_name + ' has price ' +  CAST(@list_price AS varchar);
        FETCH NEXT FROM cursor_product INTO 
            @product_name,  @list_price;
    END;

CLOSE cursor_product;

DEALLOCATE cursor_product;
End

====================================================================================================================================================================================
